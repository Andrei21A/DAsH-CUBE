//Libraries needed for the display and its connection to the Arduino board

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>


//Screen sizes
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define TRIANGLE_SIZE 8

//Connexion
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

#define BUTTON_UP_PIN 12
#define BUTTON_SELECT_PIN 8
#define BUTTON_ESC_PIN 6
#define BUTTON_DOWN_PIN 4


bool start = false;

// ' Menupage', 128x64px
const unsigned char epd_bitmap__Menupage [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
	0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
	0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
	0x00, 0x08, 0x0e, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
	0x00, 0x08, 0x06, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
	0x00, 0x08, 0x03, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
	0x00, 0x08, 0x03, 0x03, 0xe8, 0x1f, 0x0c, 0xf8, 0x00, 0x3f, 0x0c, 0x0c, 0x33, 0xc0, 0x3f, 0x00, 
	0x00, 0x3e, 0x01, 0x06, 0x3c, 0x33, 0x85, 0x98, 0x00, 0x73, 0x8c, 0x0c, 0x36, 0x60, 0x73, 0x80, 
	0x00, 0x7f, 0x81, 0x8c, 0x1c, 0x60, 0x07, 0x0c, 0x00, 0xc0, 0x0c, 0x0c, 0x3c, 0x30, 0xe1, 0x80, 
	0x00, 0xc9, 0x81, 0x88, 0x0c, 0x60, 0x06, 0x04, 0x00, 0xc0, 0x0c, 0x0c, 0x38, 0x30, 0xc0, 0x80, 
	0x00, 0xc8, 0x83, 0x18, 0x08, 0x38, 0x06, 0x04, 0x01, 0x80, 0x0c, 0x0c, 0x30, 0x11, 0x81, 0x80, 
	0x01, 0x88, 0x03, 0x18, 0x08, 0x1e, 0x04, 0x04, 0x01, 0x80, 0x0c, 0x0c, 0x30, 0x13, 0xe7, 0x80, 
	0x00, 0x8c, 0x03, 0x18, 0x08, 0x07, 0x84, 0x04, 0x01, 0x80, 0x0c, 0x0c, 0x30, 0x11, 0xfe, 0x00, 
	0x00, 0xc8, 0x06, 0x18, 0x18, 0x01, 0x8c, 0x04, 0x01, 0x80, 0x0c, 0x0c, 0x30, 0x30, 0x80, 0x00, 
	0x00, 0xc0, 0x0e, 0x18, 0x18, 0x00, 0xcc, 0x04, 0x00, 0xc0, 0x0c, 0x1c, 0x30, 0x30, 0xc0, 0x00, 
	0x00, 0x60, 0x1c, 0x0c, 0x3c, 0x40, 0x8c, 0x04, 0x00, 0xc0, 0x0c, 0x3c, 0x30, 0x60, 0xc0, 0x80, 
	0x00, 0x3c, 0xf8, 0x06, 0x6c, 0x71, 0x8c, 0x06, 0x00, 0x71, 0x86, 0x66, 0x3c, 0xe0, 0x73, 0x80, 
	0x00, 0x1f, 0xe0, 0x07, 0xcc, 0x3f, 0x0c, 0x06, 0x00, 0x3f, 0x03, 0xe6, 0x37, 0xc0, 0x3f, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x40, 0x42, 0x20, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x8e, 0x81, 0x82, 0x11, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xc0, 0x00, 0x03, 0x12, 0x01, 0x00, 0x00, 0x40, 0x00, 0x1c, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xe0, 0x00, 0x02, 0x20, 0x20, 0x00, 0x10, 0x40, 0x00, 0x1e, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xe0, 0x00, 0x02, 0x10, 0x21, 0xa0, 0x98, 0x40, 0x00, 0x1e, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf0, 0x00, 0x02, 0x0c, 0x23, 0x67, 0x90, 0x40, 0x00, 0x1f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf0, 0x00, 0x03, 0x02, 0x22, 0x26, 0x10, 0xc0, 0x00, 0x3f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x02, 0xb9, 0x20, 0x24, 0x11, 0x40, 0x00, 0x3f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf8, 0x00, 0x02, 0xa9, 0x22, 0x24, 0x10, 0x40, 0x00, 0x3f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xfc, 0x00, 0x02, 0x21, 0x22, 0x64, 0x10, 0x40, 0x00, 0x7f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xfc, 0x06, 0x02, 0x1e, 0x31, 0xf4, 0x18, 0xc0, 0x00, 0x7f, 0xc0, 0x60, 0x00, 
	0x00, 0x03, 0x07, 0xfe, 0x0e, 0x02, 0x81, 0x88, 0x42, 0x91, 0xc0, 0x30, 0x7f, 0xe0, 0xe0, 0x00, 
	0x00, 0x07, 0x87, 0xfe, 0x3e, 0x03, 0x02, 0x04, 0x41, 0x13, 0xc0, 0x78, 0x7f, 0xe3, 0xfc, 0x00, 
	0x00, 0x07, 0xcf, 0xff, 0x7f, 0x83, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x7c, 0xff, 0xf7, 0xfc, 0x00, 
	0x00, 0x0f, 0xcf, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x00, 
	0x00, 0x0f, 0xef, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x80, 
	0x00, 0x1f, 0xef, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0xff, 0xff, 0xff, 0x80, 
	0x00, 0x1f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xc0, 
	0x00, 0x3f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 
	0x00, 0x3f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 
	0x00, 0x7f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 
	0x00, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 
	0x00, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf8, 
	0x00, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfe, 
	0x07, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x0f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};


// ' Hard_Level', 16x16px
const unsigned char epd_bitmap__Hard_Level [] PROGMEM = {
	0x00, 0x00, 0x07, 0xe0, 0x0f, 0xf0, 0x1f, 0xf8, 0x37, 0xf4, 0x7b, 0xee, 0x79, 0xce, 0x7f, 0xfe, 
	0x7f, 0xfe, 0x7f, 0xfe, 0x78, 0x0e, 0x37, 0xf4, 0x1f, 0xf8, 0x0f, 0xf0, 0x07, 0xe0, 0x00, 0x00
};
// ' Medium_level', 16x16px
const unsigned char epd_bitmap__Medium_level [] PROGMEM = {
	0x00, 0x00, 0x07, 0xe0, 0x0f, 0xf0, 0x1f, 0xf8, 0x3f, 0xfc, 0x7b, 0xee, 0x7b, 0xee, 0x7f, 0xfe, 
	0x7f, 0xfe, 0x7f, 0xfe, 0x78, 0x0e, 0x3f, 0xfc, 0x1f, 0xf8, 0x0f, 0xf0, 0x07, 0xe0, 0x00, 0x00
};
// ' Easy_level', 16x16px
const unsigned char epd_bitmap__Easy_level [] PROGMEM = {
	0x00, 0x00, 0x07, 0xe0, 0x0f, 0xf0, 0x1f, 0xf8, 0x3f, 0xfc, 0x7b, 0xee, 0x7b, 0xee, 0x7f, 0xfe, 
	0x6f, 0xfa, 0x77, 0xf6, 0x78, 0x0e, 0x3f, 0xfc, 0x1f, 0xf8, 0x0f, 0xf0, 0x07, 0xe0, 0x00, 0x00
};

const unsigned char* bitmap_icons[3] = {
	epd_bitmap__Easy_level,
	epd_bitmap__Medium_level,
  epd_bitmap__Hard_Level
};

// ' Selection_bar', 128x21px
const unsigned char epd_bitmap__Selection_bar [] PROGMEM = {
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 
	0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8
};

// ' Check', 16x16px
const unsigned char epd_bitmap__Check [] PROGMEM = {
	0x00, 0x01, 0x00, 0x03, 0x00, 0x07, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0x1e, 0x18, 0x3c, 0x1c, 0x38, 
	0x1f, 0x78, 0x0f, 0xf0, 0x07, 0xf0, 0x03, 0xe0, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//levels construction
const int NUM_LEVELS = 3;

char level_menu [] [20] = {
  {"Stereo Madness"},
	{"Back On Track"},
	{"Polargeist"}
};

//selection
int level_selected = 0;
int level_selected_prev;
int level_selected_next;

//completion
bool level_completed[NUM_LEVELS] = {false, false, false}; 


//blocking variables for getting the button input just once
int button_clicked_up = 0;
int button_clicked_down = 0;
int button_clicked_select = 0;
int button_clicked_esc = 0;


// Controls
int jump = 0;
int jumpCounter = 0;
const int maxJumpHeight = 30;
bool onTop = false;

// tries counter
int tries = 0;

// Player square
int xs = 25;
int ys = 55;
int ws = 10;
int hs = 10;

// Obstacles
int count_spikes = 0;
int count_towers = 0;

// Struct obstacles
struct SpikeObstacle {
    int x1;
    int x2;
    int x3;
    int y1;
    int y2;
    int y3;

    void Display() {
        display.fillTriangle(x1, y1, x2, y2, x3, y3, WHITE);
    }
};

struct TowerObstacle {
    int x;
    int y;
    int width;
    int height;


    void Display() {
        display.fillRect(x, y, width, height, WHITE);
    }
};

SpikeObstacle spikes[3];
TowerObstacle towers[3];

//level function

void level() {
    // First wave spikes

        spikes[0].x1--;
        spikes[0].x2--;
        spikes[0].x3--;
        if (spikes[0].x1 > -20) {
            spikes[0].Display();
        }


    // First wave tower
        towers[0].x--;
        if (towers[0].x > -20) {
            towers[0].Display();
        }


    // Second wave trigger
    if (spikes[0].x1 <= SCREEN_WIDTH - 35) {
        spikes[1].x1--;
        spikes[1].x2--;
        spikes[1].x3--;
        if (spikes[1].x1 > -20) {
            spikes[1].Display();
        }
    }

    if (towers[0].x <= SCREEN_WIDTH - 35) {
        towers[1].x--;
        if (towers[1].x > -20) {
            towers[1].Display();
        }
    }

    // Third wave trigger
    if (spikes[1].x1 <= SCREEN_WIDTH - 35) {
        spikes[2].x1--;
        spikes[2].x2--;
        spikes[2].x3--;
        if (spikes[2].x1 > -20) {
            spikes[2].Display();
        }
    }

    if (towers[1].x <= SCREEN_WIDTH - 35) {
        towers[2].x--;
        if (towers[2].x > -20) {
            towers[2].Display();
        }
    }

    // Update
    if (spikes[count_spikes].x1 < -20) {
        count_spikes = (count_spikes + 1) % 3;
    }
    if (towers[count_towers].x < -20) {
        count_towers = (count_towers + 1) % 3;
    }


}

//help spike colision
//checinkg if the point of the player s square is in the area of the spike(A1 + A2 + A3 = A)
bool pointInTriangle(int px, int py, int x1, int y1, int x2, int y2, int x3, int y3) {
    float A = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0);
    
    float A1 = abs((px * (y2 - y3) + x2 * (y3 - py) + x3 * (py - y2)) / 2.0);
    float A2 = abs((x1 * (py - y3) + px * (y3 - y1) + x3 * (y1 - py)) / 2.0);
    float A3 = abs((x1 * (y2 - py) + x2 * (py - y1) + px * (y1 - y2)) / 2.0);
    
    return abs(A - (A1 + A2 + A3)) < 0.1;
}

//Reseting levels
void resetLevel() {
    // Reset player position
    xs = 25;
    ys = 55;
    ws = 10;
    hs = 10;

    //Reseting obstacles for the respective level
    if(level_selected == 0) {
        spikes[0] = {130, 140, 135, 64, 64, 55};
        spikes[1] = {180, 190, 185, 64, 64, 55};
        spikes[2] = {230, 240, 235, 64, 64, 55};

        towers[0] = {190, 45, 10, 25};
        towers[1] = {200, 45, 10, 25};
        towers[2] = {260, 45, 10, 25};

    }
    else if (level_selected == 1) {

        spikes[0] = {190, 200, 195, 64, 64, 55};
        spikes[1] = {200, 210, 205, 64, 64, 55};
        spikes[2] = {230, 240, 235, 64, 64, 55};

        towers[0] = {130, 45, 10, 25};
        towers[1] = {130, 45, 10, 25};
        towers[2] = {200, 45, 10, 25};
    }
    else if (level_selected == 2) {

        spikes[0] = {130, 140, 135, 64, 64, 55};
        spikes[1] = {132, 142, 137, 64, 64, 55};
        spikes[2] = {230, 240, 235, 64, 64, 55};

        towers[0] = {190, 45, 10, 25};
        towers[1] = {170, 45, 10, 25};
        towers[2] = {190, 45, 10, 25};
    }

    // Reset counters
    count_spikes = 0;
    count_towers = 0;

    // Reset jump states
    jump = 0;
    jumpCounter = 0;
    onTop = false;

    // Clear the display
    display.clearDisplay();
    display.display();
}


void setup() {

  pinMode(BUTTON_UP_PIN, INPUT_PULLUP);
  pinMode(BUTTON_SELECT_PIN, INPUT_PULLUP);
  pinMode(BUTTON_DOWN_PIN, INPUT_PULLUP);
	pinMode(BUTTON_ESC_PIN, INPUT_PULLUP);

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
        for (;;);
    }

  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.display();

}


//level selection
int selectl1 = 0;
int selectl2 = 0;
int selectl3 = 0;

void loop() {

  if(selectl1 == 1 || selectl2 == 1 || selectl3 == 1)gameloop();
  else {
    if (digitalRead(BUTTON_UP_PIN) == LOW && button_clicked_up == 0) {
      level_selected = level_selected - 1;
      button_clicked_up = 1;
      if (level_selected < 0) {
          level_selected = NUM_LEVELS - 1;
      }
  }

    if (digitalRead(BUTTON_DOWN_PIN) == LOW && button_clicked_down == 0) {
      level_selected = level_selected + 1;
      button_clicked_down = 1;
      if (level_selected >= NUM_LEVELS) {
        level_selected = 0;
      }
    }

    if (digitalRead(BUTTON_UP_PIN) == HIGH && button_clicked_up == 1) {
      button_clicked_up = 0;
    }

    if(digitalRead(BUTTON_DOWN_PIN) == HIGH && button_clicked_down == 1) {
      button_clicked_down = 0;
    }

    level_selected_prev = level_selected - 1;
    if (level_selected_prev < 0) {
      level_selected_prev = NUM_LEVELS - 1;
    }

    level_selected_next = level_selected + 1;
    if (level_selected_next >= NUM_LEVELS) {
      level_selected_next = 0;
    }

    if(digitalRead(BUTTON_SELECT_PIN) == LOW && level_selected == 0) {
      selectl1 = 1;
      spikes[0] = {130, 140, 135, 64, 64, 55};
      spikes[1] = {180, 190, 185, 64, 64, 55};
      spikes[2] = {230, 240, 235, 64, 64, 55};

      towers[0] = {190, 45, 10, 25};
      towers[1] = {200, 45, 10, 25};
      towers[2] = {260, 45, 10, 25};

    }
    else if (digitalRead(BUTTON_SELECT_PIN) == LOW && level_selected == 1) {
      selectl2 = 1;
      spikes[0] = {190, 200, 195, 64, 64, 55};
      spikes[1] = {200, 210, 205, 64, 64, 55};
      spikes[2] = {230, 240, 235, 64, 64, 55};

      towers[0] = {130, 45, 10, 25};
      towers[1] = {130, 45, 10, 25};
      towers[2] = {200, 45, 10, 25};

    }
    else if (digitalRead(BUTTON_SELECT_PIN) == LOW && level_selected == 2) {
      selectl3 = 1;
      spikes[0] = {130, 140, 135, 64, 64, 55};
      spikes[1] = {132, 142, 137, 64, 64, 55};
      spikes[2] = {230, 240, 235, 64, 64, 55};

      towers[0] = {190, 45, 10, 25};
      towers[1] = {170, 45, 10, 25};
      towers[2] = {190, 45, 10, 25};

    }

    display.clearDisplay();
    if(start == false) 
    {
      display.drawBitmap(0, 0, epd_bitmap__Menupage, 128, 64, WHITE);
			
      if (digitalRead(BUTTON_SELECT_PIN) == LOW){
        start = true;
        delay(100);
      }
    }
    else {
      display.setTextSize(1);
      display.setTextColor(WHITE);
      
      //PreviousItem
      display.drawBitmap(2, 2, bitmap_icons[level_selected_prev], 16, 16, WHITE);
      display.setCursor(26, 7);
      display.print(level_menu[level_selected_prev]);
      if (level_completed[level_selected_prev]) {
        display.drawBitmap(112, 2, epd_bitmap__Check, 16, 16, WHITE);
      }

      //SelectedItem
      display.setCursor(26, 29);
      display.print(level_menu[level_selected]);
      display.drawBitmap(4, 24, bitmap_icons[level_selected], 16, 16, WHITE);
      if (level_completed[level_selected]) {
        display.drawBitmap(112, 24, epd_bitmap__Check, 16, 16, WHITE);
      }

      //NextItem
      display.drawBitmap(2, 46, bitmap_icons[level_selected_next], 16, 16, WHITE);
      display.setCursor(26, 51);
      display.print(level_menu[level_selected_next]);
      if (level_completed[level_selected_next]) {
        display.drawBitmap(112, 46, epd_bitmap__Check, 16, 16, WHITE);
      }
      display.drawBitmap(1, 22, epd_bitmap__Selection_bar, 128, 21, WHITE);
    }
    display.display();
  }
  
}

void gameloop() {

	if(digitalRead(BUTTON_ESC_PIN) == LOW) {
        button_clicked_esc = 1;
        selectl1 = 0;
        selectl2 = 0;  
        selectl3 = 0;  
        tries = 0;     
    }

		
  display.clearDisplay();

    display.setTextSize(1);
    display.setCursor(1, 1);
    display.print("ATTEMPT: ");
    display.print(tries);

    level();

    onTop = false;


    //Colisions spikes
if (spikes[count_spikes].x1 > -20 && spikes[count_spikes].x1 < SCREEN_WIDTH + 20) {
    bool collision = false;

    // Top-left corner
    if (pointInTriangle(xs, ys,
                        spikes[count_spikes].x1, spikes[count_spikes].y1,
                        spikes[count_spikes].x2, spikes[count_spikes].y2,
                        spikes[count_spikes].x3, spikes[count_spikes].y3)) {
        collision = true;
    }
    // Top-right corner
    if (pointInTriangle(xs + ws, ys,
                        spikes[count_spikes].x1, spikes[count_spikes].y1,
                        spikes[count_spikes].x2, spikes[count_spikes].y2,
                        spikes[count_spikes].x3, spikes[count_spikes].y3)) {
        collision = true;
    }
    // Bottom-left corner
    if (pointInTriangle(xs, ys + hs,
                        spikes[count_spikes].x1, spikes[count_spikes].y1,
                        spikes[count_spikes].x2, spikes[count_spikes].y2,
                        spikes[count_spikes].x3, spikes[count_spikes].y3)) {
        collision = true;
    }
    // Bottom-right corner
    if (pointInTriangle(xs + ws, ys + hs,
                        spikes[count_spikes].x1, spikes[count_spikes].y1,
                        spikes[count_spikes].x2, spikes[count_spikes].y2,
                        spikes[count_spikes].x3, spikes[count_spikes].y3)) {
        collision = true;
    }

    // If collision, reset level
    if (collision) {
        tries++;
        resetLevel();
        return;
    }
}

// Check for collision with the second spike (count_spikes + 1)
if (count_spikes + 1 < 3) {
    if (spikes[count_spikes + 1].x1 > -20 && spikes[count_spikes + 1].x1 < SCREEN_WIDTH + 20) {
        bool collision = false;

        // Top-left corner
        if (pointInTriangle(xs, ys,
                            spikes[count_spikes + 1].x1, spikes[count_spikes + 1].y1,
                            spikes[count_spikes + 1].x2, spikes[count_spikes + 1].y2,
                            spikes[count_spikes + 1].x3, spikes[count_spikes + 1].y3)) {
            collision = true;
        }
        // Top-right corner
        if (pointInTriangle(xs + ws, ys,
                            spikes[count_spikes + 1].x1, spikes[count_spikes + 1].y1,
                            spikes[count_spikes + 1].x2, spikes[count_spikes + 1].y2,
                            spikes[count_spikes + 1].x3, spikes[count_spikes + 1].y3)) {
            collision = true;
        }
        // Bottom-left corner
        if (pointInTriangle(xs, ys + hs,
                            spikes[count_spikes + 1].x1, spikes[count_spikes + 1].y1,
                            spikes[count_spikes + 1].x2, spikes[count_spikes + 1].y2,
                            spikes[count_spikes + 1].x3, spikes[count_spikes + 1].y3)) {
            collision = true;
        }
        // Bottom-right corner
        if (pointInTriangle(xs + ws, ys + hs,
                            spikes[count_spikes + 1].x1, spikes[count_spikes + 1].y1,
                            spikes[count_spikes + 1].x2, spikes[count_spikes + 1].y2,
                            spikes[count_spikes + 1].x3, spikes[count_spikes + 1].y3)) {
            collision = true;
        }

        // If collision, reset level
        if (collision) {
            tries++;
            resetLevel();
            return;
        }
    }
}

// Current tower collision logic
if (towers[count_towers].x > 0 && towers[count_towers].x < SCREEN_WIDTH) {
    
    // Collision horizontal
    if (xs + ws > towers[count_towers].x && xs < towers[count_towers].x + towers[count_towers].width) {
        
        // Collision vertical
        if (ys + hs >= towers[count_towers].y && ys < towers[count_towers].y + towers[count_towers].height) {
            
            // Landing on the tower
            if (ys + hs - towers[count_towers].y < 1 && !onTop) {  
                ys = towers[count_towers].y - hs;
                onTop = true;
                jump = 0;
            } else if (ys + hs - towers[count_towers].y >= 1) {
                tries++;
                resetLevel();
                return;
            }

            // Staying on top
            if (onTop) {
                ys = towers[count_towers].y - hs;
            }
        }
    } else {
        // Gravity if not on the tower
        if (onTop) {
            onTop = false;
        }
    }
}

if (count_towers + 1 < 3) { 
    int nextTowerX = towers[count_towers + 1].x;
    int nextTowerY = towers[count_towers + 1].y;
    int nextTowerWidth = towers[count_towers + 1].width;
    int nextTowerHeight = towers[count_towers + 1].height;

    if (xs + ws > nextTowerX && xs < nextTowerX + nextTowerWidth) {

        if (ys + hs >= nextTowerY && ys + hs <= nextTowerY + 3) { 
            ys = nextTowerY - hs; 
            onTop = true;
            jump = 0;
            count_towers++;
        }
    }
}


if (digitalRead(BUTTON_UP_PIN) == LOW && (jump == 0 && (ys >= 55 || onTop))) {
    jump = 1;
    jumpCounter = 0;
    onTop = false;
}

if (jump == 1) {
    ys -= 2;
    jumpCounter += 2;
    if (jumpCounter >= maxJumpHeight) {
        jump = 2;
    }
} else if (jump == 2) {
    if (!onTop) {
        ys += 1;
        if (ys >= 55) {
            ys = 55;
            jump = 0;
        }
    }
}

// Gravity
if (!onTop && jump == 0 && ys < 55) {
    ys += 1;
}



    if (spikes[count_spikes].x1 < -20 && towers[count_towers].x < -20) {
        display.setTextSize(2);
        display.setCursor(20, 30);
        display.print("YOU WIN!");
        display.display();
        delay(2000);
        if(selectl1 == 1)
        {
          level_completed[0] = true;
          selectl1 = 0;
        }
        else if(selectl2 == 1){
          level_completed[1] = true;
          selectl2 = 0;
          }
        else {
          level_completed[2] = true;
          selectl3 = 0;
        }
        resetLevel();  
        tries = 0;
    }

    // Draw player
    display.fillRect(xs, ys, ws, hs, WHITE);
    
    display.display();
}
